\documentclass[prl,twocolumn,superscriptaddress,preprintnumbers,floatfix]{revtex4-1}

\usepackage{etex}
\usepackage{ifpdf}
\usepackage{hyperref}
\usepackage{dcolumn}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amscd}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bm}   % bold math
\usepackage{bbm}
\usepackage{verbatim}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{cleveref}
\usepackage{graphicx}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{positioning}
\usetikzlibrary{plotmarks}
\usetikzlibrary{calc}
\usetikzlibrary{patterns}
\usetikzlibrary{external}
\tikzexternalize
\tikzsetexternalprefix{images/}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}

\input{macros}

\begin{document}

\title{Mathematical Foundations of Computational Mechanics}

\author{Ryan G. James}
\email{ryan.james@colorado.edu}
\affiliation{Department of Computer Science, University of Colorado at Boulder, Boulder, Colorado 80309}

\author{Nicole F. Sanderson}
\email{nicole.sanderson@colorado.edu}
\affiliation{Department of Mathematics, University of Colorado at Boulder, Boulder, Colorado 80309}

\date{\today}
\bibliographystyle{unsrt}

\date{\today}

\begin{abstract}

We make rigorous the extension of formal language theory to processes and further extend the theory to include atoms. 

\vspace{0.1in}
\noindent {\bf Keywords}:

\end{abstract}

\maketitle


\section{Notes}
Formal language theory utilizes the notions of (left) quotients, (right) quotients, right languages, and left languages to characterize languages.  Our goal is to rigorously define analogous concepts in the realm of processes.  A language \Language is defined to be a subset of the free monoid $\Sigma^{\star}$on an alphabet $\Sigma$. The (left) quotient of a language \Language for a word $w$ is defined to be $w^{-1}\Language = \{ x | wx \in \Language \}$. 

A process \Process is defined to be $\{\subseteq \Sigma^{\mathbb{Z}}, \mu\}$ where $\Sigma^{\mathbb{Z}}$ is the set of bi-infinite strings over the alphabet $\Sigma$ and $\mu$ is a shift-invariant measure on this space.  

Our working definitions are as follows: 

The (left) quotient of a process \Process is defined to be $\overleftarrow{w} \Process 
= \{ \{\overrightarrow{x}, \mu_{\overleftarrow{w}} \} | \mu(\overleftarrow{w}\overrightarrow{x}) \neq 0 \}$. 

We are thinking that we want $\mu_{\overleftarrow{w}}$ to be something like the sum over states we can be in after having seen $\overleftarrow{w}$ of the probability of seeing $\overrightarrow{x}$ from that state} times the probability of being in that state.  We'll need to make sure this is actually a measure, and we want this quotient to include the data of both the support as well as a probability distribution.  

A given language \Language has a set of quotients.  One way of defining a regular language is that the language has a finite set of quotients.  The atoms of a language are defined to be the intersections of all the (either) quotients or complements of the quotients in $\Sigma^{\start}$.  

Difference between language and process: if there are a finite number of left quotients, then there are a finite number or right quotients (this comes from the reverse of a regular language being regular, seen from reversing DFA).  Not true for processes, since the reverse of a unifilar (stationary, recurrent, blah blah blah) HMM is not necessarily unifilar and making it unifilar might make it infinite. Example: INSERT.  

*STATE MORPHS (i.e. right language of state)

(left) Quotients translate to (future) morphs. (right) Quotients correspond to (past) morphs.  We need to figure out what intersection means for morphs.  We can construct the atoms directly to determine this.  Recall, one way of constructing atoms for a language \Language is to reverse the minimal DFA of $\Language^{R}$.  The atoms are then the right languages of the states. We can do the analogous process for processes where we reverse the epsilon-machine of the reverse process, and look at the future morphs of the states of that "etomata" (a typically non-unifilar HMM).

We want something like intersections, but over distributions of future morphs.  We know the future morphs, and the atoms.  Now we need to determine the operator to get from A to B.  

Define Reverse Process: (limiting set of word probabilities - def, reverse the words at each step) would be nice to define directly on subshift. hoping that shift invariance of measure means we don't care where we flip it, all words should be in it.  We want to match up with the process that reversing the epsilon machine representation of a given process spits out. [see Nick Travers]

Define Co-regular processes: We're calling processes with a finite epsilon-machine representation regular. Co-regular processes are those where the epsilon machine representation of the process, and the epsilon machine representation of the process achieved by reversing the epsilon machine (might result in a non-unifilar HMM) are finite.  These set of processes could be special - good to calculate E (excess entropy).  *Co-unifilar implies reverse epsilon machine isomorphic to epsilon machine (2 part proof, gauge info = 0 of epsilon machine, feed future backwards into e-machine). Co-unifilar gets us K = I = C = $C_{\mu}$ = E.  (also, if $C_{\mu} = E, know co-unifilar)

**Gac's-Korner information, mutual information is not a random variable 

\bibliographystyle{unsrt}
\bibliography{bibliography}

\end{document}
